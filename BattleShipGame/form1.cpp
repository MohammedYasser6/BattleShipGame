// Form1.cpp
#include "Form1.h" // Includes the header file for the Form1 class, which is the main UI form.
#include <string> // Includes the standard C++ string library (used by BattleshipGameLogic, not directly here).
#include <vector> // Includes the standard C++ vector library (used by BattleshipGameLogic, not directly here).
#include <msclr/marshal_cppstd.h> // Includes the MS C++/CLI marshalling library for converting between .NET System::String and std::string.

// .NET USING DIRECTIVES - these bring common .NET namespaces into scope for easier use.
using namespace System; // Base System namespace, provides fundamental classes and base types.
using namespace System::ComponentModel; // Provides classes used for implementing the run-time and design-time behavior of components and controls.
using namespace System::Collections; // Provides interfaces and classes that define various collections of objects.
using namespace System::Collections::Generic; // Provides interfaces and classes that define generic collections.
using namespace System::Windows::Forms; // Provides classes for creating Windows-based applications that take full advantage of the rich user interface features.
using namespace System::Data; // Provides classes for accessing and managing data from various sources.
using namespace System::Drawing; // Provides access to GDI+ basic graphics functionality.
using namespace System::Net; // Provides a simple programming interface for many of the protocols used on networks today.
using namespace System::Net::Sockets; // Provides a managed implementation of the Windows Sockets (Winsock) interface.
using namespace System::Threading; // Provides classes and interfaces that enable multithreaded programming.
using namespace System::Text; // Contains classes that represent ASCII, Unicode, UTF-7, and UTF-8 character encodings.
using namespace System::IO; // Provides types for reading and writing to files and data streams.
using namespace System::Media; // Provides types for playing sound files and accessing system sounds.

namespace BattleshipGame { // Defines the namespace for the Battleship game UI elements.

    // Helper function to convert a GameTurn enum (assumed to be from BattleshipGameLogic.h, though not shown here) to a .NET String.
    // Kept for potential debugging or logging purposes.
    String^ GameTurnToLogString(GameTurn turn) {
        switch (turn) { // Switch statement to handle different GameTurn enum values.
        case GameTurn::PLAYER1: return L"P1_TURN"; // If turn is PLAYER1, return "P1_TURN".
        case GameTurn::PLAYER2: return L"P2_TURN"; // If turn is PLAYER2, return "P2_TURN".
        case GameTurn::GAME_OVER_P1_WINS: return L"P1_WINS"; // If P1 wins, return "P1_WINS".
        case GameTurn::GAME_OVER_P2_WINS: return L"P2_WINS"; // If P2 wins, return "P2_WINS".
        case GameTurn::SETUP: return L"SETUP"; // If in setup phase, return "SETUP".
        default: return String::Format(L"UnknownTurn ({0})", static_cast<int>(turn)); // For any other value, return an "UnknownTurn" string.
        }
    }

    // Constructor for the Form1 class.
    Form1::Form1(void) {
        InitializeComponent(); // Calls the method to initialize all UI controls (auto-generated by Windows Forms Designer).
        std::srand(static_cast<unsigned int>(std::time(nullptr))); // Seeds the standard C++ random number generator (used by gameLogicServer).
        gameLogicServer = nullptr; // Initializes the pointer to the native game logic server object to null.
        isHost = false; isConnected = false; myPlayerId = 0; // Initializes network state flags and player ID.
        opponentName = gcnew String(L"Opponent"); // Initializes the opponent's name to a default value.
        gameActive = false; isMyTurn = false; // Initializes game state flags.
        clientSentReady = false; hostAcknowledgedClientReady = false; // Initializes flags for the ready-up sequence.

        UIMessageQueue = gcnew System::Collections::Generic::Queue<String^>(); // Creates a new generic queue to hold incoming network messages for UI processing.
        queueLock = gcnew Object(); // Creates a new object to use as a lock for synchronizing access to UIMessageQueue.
        messageProcessTimer = gcnew System::Windows::Forms::Timer(this->components); // Creates a new Timer component.
        messageProcessTimer->Interval = 50; // Sets the timer interval to 50 milliseconds.
        messageProcessTimer->Tick += gcnew System::EventHandler(this, &Form1::OnMessageProcessTimerTick); // Assigns an event handler for the timer's Tick event.

        backgroundMusicPlayer = gcnew SoundPlayer(); // Creates a new SoundPlayer object for background music.
        try { // Try block to handle potential exceptions during file loading.
            String^ audioFilePath = Path::Combine(Application::StartupPath, "background_music.wav"); // Constructs the full path to the music file.
            if (File::Exists(audioFilePath)) { // Checks if the music file exists at the specified path.
                backgroundMusicPlayer->SoundLocation = audioFilePath; // Sets the location of the sound file.
                backgroundMusicPlayer->Load(); // Loads the sound file into memory.
            }
        }
        catch (Exception^) { /* If an exception occurs (e.g., file not found, invalid format), it's caught here. Logging might occur in Form1_Load. */ }

        InitializeGameGrids(); // Calls a custom method to set up the game board button grids.
        myNameInternal = playerNameTextBox->Text; // Gets the initial player name from the TextBox.
        if (String::IsNullOrWhiteSpace(myNameInternal)) myNameInternal = gcnew String(L"Player"); // If the name is empty, sets a default name.

        ResetGameAndUI(); // Calls a method to reset the game state and UI to their initial conditions.
        this->FormClosing += gcnew FormClosingEventHandler(this, &Form1::OnFormClosing); // Assigns an event handler for the form's Closing event.
        messageProcessTimer->Start(); // Starts the message processing timer.
    }

    // Initializes all UI components on the form. This method is primarily managed by the Windows Forms Designer.
    void Form1::InitializeComponent(void) {
        this->components = gcnew System::ComponentModel::Container(); // Creates a container for components (e.g., timers).
        this->SuspendLayout(); // Suspends layout logic for the form while controls are being added/modified.

        // Create Controls (these lines assume these controls are declared as members in Form1.h)
        this->networkSetupGroupBox = gcnew GroupBox(); // Creates a new GroupBox for network setup controls.
        this->pvpRadioButton = gcnew RadioButton(); // Creates a RadioButton (though it's set to enabled=false, indicating fixed PvP mode).
        this->playerNameLabel = gcnew Label(); // Creates a Label for the player name input.
        this->playerNameTextBox = gcnew TextBox(); // Creates a TextBox for player name input.
        this->serverIpLabel = gcnew Label(); // Creates a Label for the server IP input.
        this->serverIpTextBox = gcnew TextBox(); // Creates a TextBox for server IP input (when joining).
        this->portLabel = gcnew Label(); // Creates a Label for the port number input.
        this->portTextBox = gcnew TextBox(); // Creates a TextBox for port number input.
        this->hostGameButton = gcnew Button(); // Creates a Button to host a new game.
        this->joinGameButton = gcnew Button(); // Creates a Button to join an existing game.
        this->statusLabel = gcnew Label(); // Creates a Label to display status messages and logs.
        this->playerOwnBoardPanel = gcnew TableLayoutPanel(); // Creates a TableLayoutPanel for the player's own ships.
        this->playerTrackingBoardPanel = gcnew TableLayoutPanel(); // Creates a TableLayoutPanel for tracking opponent's ships.
        this->ownBoardLabel = gcnew Label(); // Creates a Label for the player's own board.
        this->trackingBoardLabel = gcnew Label(); // Creates a Label for the player's tracking board.
        this->controlButton = gcnew Button(); // Creates a general-purpose control button (e.g., "Ready").

        // --- networkSetupGroupBox Properties ---
        this->networkSetupGroupBox->SuspendLayout(); // Suspends layout for the group box itself.
        this->networkSetupGroupBox->Controls->Add(this->pvpRadioButton); // Adds PvP radio button to the group box.
        this->networkSetupGroupBox->Controls->Add(this->playerNameLabel); // Adds player name label.
        this->networkSetupGroupBox->Controls->Add(this->playerNameTextBox); // Adds player name text box.
        this->networkSetupGroupBox->Controls->Add(this->serverIpLabel); // Adds server IP label.
        this->networkSetupGroupBox->Controls->Add(this->serverIpTextBox); // Adds server IP text box.
        this->networkSetupGroupBox->Controls->Add(this->portLabel); // Adds port label.
        this->networkSetupGroupBox->Controls->Add(this->portTextBox); // Adds port text box.
        this->networkSetupGroupBox->Controls->Add(this->hostGameButton); // Adds host game button.
        this->networkSetupGroupBox->Controls->Add(this->joinGameButton); // Adds join game button.
        this->networkSetupGroupBox->TabIndex = 0; // Sets the tab order index for the group box.
        this->networkSetupGroupBox->TabStop = false; // Indicates the group box itself is not a tab stop.
        this->networkSetupGroupBox->Text = L"Network Game Setup"; // Sets the display text for the group box's border.

        // --- Controls inside networkSetupGroupBox ---
        int controlSpacing = 6; // Defines vertical spacing between controls inside the group box.
        this->pvpRadioButton->AutoSize = true; // Allows the radio button to resize based on its text.
        this->pvpRadioButton->Checked = true; // Sets the radio button as checked by default.
        this->pvpRadioButton->Location = Point(10, 20); // Sets its position within the group box.
        this->pvpRadioButton->Name = L"pvpRadioButton"; // Sets its programmatic name.
        this->pvpRadioButton->Text = L"Network PvP Mode"; // Sets its display text.
        this->pvpRadioButton->UseVisualStyleBackColor = true; // Uses the default system appearance.
        this->pvpRadioButton->Enabled = false; // Disables the radio button, as only one mode (Network PvP) is implied by this setup.
        this->pvpRadioButton->CheckedChanged += gcnew EventHandler(this, &Form1::OnPvpRadioButtonChanged); // Assigns an event handler for its CheckedChanged event.

        int currentY_inGroup = this->pvpRadioButton->Bottom + controlSpacing + 5; // Calculates Y position for the next control.
        this->playerNameLabel->AutoSize = true; // Label resizes to fit text.
        this->playerNameLabel->Location = Point(10, currentY_inGroup + 3); // Sets its position (with a small vertical adjustment for alignment).
        this->playerNameLabel->Name = L"playerNameLabel"; // Sets its name.
        this->playerNameLabel->Text = L"Your Name:"; // Sets its display text.
        this->playerNameTextBox->Location = Point(100, currentY_inGroup); // Sets position for the name TextBox.
        this->playerNameTextBox->Name = L"playerNameTextBox"; // Sets its name.
        this->playerNameTextBox->Size = Drawing::Size(170, 22); // Sets its size.
        this->playerNameTextBox->TabIndex = 1; // Sets its tab index.
        this->playerNameTextBox->Text = L"Player1"; // Sets default text.

        currentY_inGroup = this->playerNameTextBox->Bottom + controlSpacing; // Update Y for next control.
        this->serverIpLabel->AutoSize = true; // Label resizes.
        this->serverIpLabel->Location = Point(10, currentY_inGroup + 3); // Sets its position.
        this->serverIpLabel->Name = L"serverIpLabel"; // Sets its name.
        this->serverIpLabel->Text = L"Server IP (Join):"; // Sets its display text.
        this->serverIpTextBox->Location = Point(130, currentY_inGroup); // Sets position for IP TextBox.
        this->serverIpTextBox->Name = L"serverIpTextBox"; // Sets its name.
        this->serverIpTextBox->Size = Drawing::Size(140, 22); // Sets its size.
        this->serverIpTextBox->TabIndex = 2; // Sets its tab index.
        this->serverIpTextBox->Text = L"localhost"; // Default IP for joining (often for local testing).

        currentY_inGroup = this->serverIpTextBox->Bottom + controlSpacing; // Update Y.
        this->portLabel->AutoSize = true; // Label resizes.
        this->portLabel->Location = Point(10, currentY_inGroup + 3); // Sets its position.
        this->portLabel->Name = L"portLabel"; // Sets its name.
        this->portLabel->Text = L"Port:"; // Sets its display text.
        this->portTextBox->Location = Point(130, currentY_inGroup); // Sets position for port TextBox.
        this->portTextBox->Name = L"portTextBox"; // Sets its name.
        this->portTextBox->Size = Drawing::Size(70, 22); // Sets its size.
        this->portTextBox->TabIndex = 3; // Sets its tab index.
        this->portTextBox->Text = L"12345"; // Default port number.

        currentY_inGroup = this->portTextBox->Bottom + controlSpacing + 10; // Update Y, with extra spacing.
        this->hostGameButton->Location = Point(30, currentY_inGroup); // Sets position for Host button.
        this->hostGameButton->Name = L"hostGameButton"; // Sets its name.
        this->hostGameButton->Size = Drawing::Size(100, 30); // Sets its size.
        this->hostGameButton->TabIndex = 4; // Sets its tab index.
        this->hostGameButton->Text = L"Host Game"; // Sets its display text.
        this->hostGameButton->UseVisualStyleBackColor = true; // Uses default system appearance.
        this->hostGameButton->Click += gcnew EventHandler(this, &Form1::OnHostGameClick); // Assigns its Click event handler.

        this->joinGameButton->Location = Point(150, currentY_inGroup); // Sets position for Join button.
        this->joinGameButton->Name = L"joinGameButton"; // Sets its name.
        this->joinGameButton->Size = Drawing::Size(100, 30); // Sets its size.
        this->joinGameButton->TabIndex = 5; // Sets its tab index.
        this->joinGameButton->Text = L"Join Game"; // Sets its display text.
        this->joinGameButton->UseVisualStyleBackColor = true; // Uses default system appearance.
        this->joinGameButton->Click += gcnew EventHandler(this, &Form1::OnJoinGameClick); // Assigns its Click event handler.

        // Size the GroupBox to fit all its child controls.
        this->networkSetupGroupBox->Size = Drawing::Size(290, this->joinGameButton->Bottom + 15); // Width 290, height based on last control + padding.
        this->networkSetupGroupBox->ResumeLayout(false); // Resumes layout for the group box.
        this->networkSetupGroupBox->PerformLayout(); // Forces layout of child controls within group box.


        // --- Layout Parameters for the rest of the form ---
        int leftWindowMargin = 20; // Margin from the left edge of the form.
        int topWindowMargin = 12; // Margin from the top edge of the form.
        int verticalElementSpacing = 15; // Vertical spacing between major UI elements.
        int horizontalElementSpacing = 20; // Horizontal spacing (not heavily used in this specific layout).
        int boardLabelToBoardSpacing = 5; // Vertical spacing between a board's label and the board panel itself.
        int interBoardSpacing = 50; // Horizontal spacing between the "own" board and "tracking" board.

        // --- Position Setup Group (already done, but could be re-set here if needed) ---
        this->networkSetupGroupBox->Location = Point(leftWindowMargin, topWindowMargin); // Confirms/sets position of the setup group box.

        // --- Calculate Board Dimensions ---
        int singleBoardWidth = (440); // Sets a fixed width for a single game board panel.
        // Comment notes CellBorderStyle adds 1px per cell line, but fixed size is used here.
        int singleBoardHeight = (400); // Sets a fixed height for a single game board panel.

        // --- Position Game Boards Area ---
        int boardsAreaTopY = this->networkSetupGroupBox->Bottom + verticalElementSpacing; // Y-coordinate for the top of the game boards area.

        // Own Board (Player's own ships)
        this->ownBoardLabel->AutoSize = true; // Label resizes.
        this->ownBoardLabel->Location = Point(leftWindowMargin, boardsAreaTopY); // Sets position for own board label.
        this->ownBoardLabel->Name = L"ownBoardLabel"; // Sets its name.
        this->ownBoardLabel->Text = L"Your Ships:"; // Sets default display text.
        this->playerOwnBoardPanel->CellBorderStyle = TableLayoutPanelCellBorderStyle::Single; // Adds single-pixel border to cells.
        this->playerOwnBoardPanel->Location = Point(leftWindowMargin, this->ownBoardLabel->Bottom + boardLabelToBoardSpacing); // Positions panel below its label.
        this->playerOwnBoardPanel->Name = L"playerOwnBoardPanel"; // Sets its name.
        this->playerOwnBoardPanel->Size = Drawing::Size(singleBoardWidth, singleBoardHeight); // Sets its size.
        this->playerOwnBoardPanel->TabIndex = 8; // Sets its tab index.

        // Tracking Board (For attacking opponent)
        int trackingBoardX = this->playerOwnBoardPanel->Right + interBoardSpacing; // X-coordinate for tracking board, right of own board + spacing.
        this->trackingBoardLabel->AutoSize = true; // Label resizes.
        this->trackingBoardLabel->Location = Point(trackingBoardX, boardsAreaTopY); // Sets position for tracking board label.
        this->trackingBoardLabel->Name = L"trackingBoardLabel"; // Sets its name.
        this->trackingBoardLabel->Text = L"Tracking Board:"; // Sets default display text.
        this->playerTrackingBoardPanel->CellBorderStyle = TableLayoutPanelCellBorderStyle::Single; // Adds cell borders.
        this->playerTrackingBoardPanel->Location = Point(trackingBoardX, this->trackingBoardLabel->Bottom + boardLabelToBoardSpacing); // Positions panel below its label.
        this->playerTrackingBoardPanel->Name = L"playerTrackingBoardPanel"; // Sets its name.
        this->playerTrackingBoardPanel->Size = Drawing::Size(singleBoardWidth, singleBoardHeight); // Sets its size.
        this->playerTrackingBoardPanel->TabIndex = 9; // Sets its tab index.

        // --- Position Status Label and Control Button (typically below the game boards) ---
        int bottomOfBoards = this->playerOwnBoardPanel->Bottom; // Gets Y-coordinate of the bottom of the board area.
        this->statusLabel->Location = Point(leftWindowMargin, bottomOfBoards + verticalElementSpacing); // Positions status label below boards.
        this->statusLabel->Name = L"statusLabel"; // Sets its name.
        // Calculates width for status label: either spans both boards or a minimum of 400px.
        int statusLabelWidth = Math::Max(this->playerTrackingBoardPanel->Right - leftWindowMargin, 400);
        this->statusLabel->Size = Drawing::Size(statusLabelWidth, 100); // Sets its size (increased height for multiple log lines).
        this->statusLabel->TextAlign = ContentAlignment::TopLeft; // Aligns text to top-left for log-like display.
        this->statusLabel->BorderStyle = BorderStyle::FixedSingle; // Adds a border for visual separation.
        this->statusLabel->Font = gcnew Drawing::Font(L"Segoe UI", 9.0F, FontStyle::Regular); // Sets its font.
        this->statusLabel->TabIndex = 6; // Sets its tab index.
        this->statusLabel->Text = L"Welcome! Setup or join a game."; // Sets initial text.

        this->controlButton->Location = Point(leftWindowMargin, this->statusLabel->Bottom + controlSpacing); // Positions control button below status label.
        this->controlButton->Name = L"controlButton"; // Sets its name.
        this->controlButton->Size = Drawing::Size(180, 35); // Sets its size.
        this->controlButton->TabIndex = 7; // Sets its tab index.
        this->controlButton->Text = L"Ready"; // Sets default display text (will change based on game state).
        this->controlButton->UseVisualStyleBackColor = true; // Uses default system appearance.
        this->controlButton->Click += gcnew EventHandler(this, &Form1::OnControlButtonClick); // Assigns its Click event handler.

        // --- Form Properties ---
        this->AutoScaleDimensions = Drawing::SizeF(8.0F, 16.0F); // Sets scaling dimensions for DPI awareness.
        this->AutoScaleMode = Windows::Forms::AutoScaleMode::Font; // Sets auto-scaling mode.

        // Calculate final ClientSize for the form to fit all content.
        // Required width is the maximum of the right edge of tracking board or status label, plus margin.
        int requiredWidth = Math::Max(this->playerTrackingBoardPanel->Right + leftWindowMargin, this->statusLabel->Right + leftWindowMargin);
        // Required height is the bottom edge of the lowest control (controlButton) plus margin/padding.
        int requiredHeight = this->controlButton->Bottom + leftWindowMargin + 10;

        this->ClientSize = Drawing::Size(requiredWidth, requiredHeight); // Sets the client area size of the form.
        this->Text = L"Battleship PvP"; // Sets the title bar text of the form.
        this->FormBorderStyle = Windows::Forms::FormBorderStyle::FixedSingle; // Prevents resizing of the form.
        this->MaximizeBox = false; // Disables the maximize button.
        this->Name = L"Form1"; // Sets the programmatic name of the form.

        // Add Top-Level Controls to Form's Controls collection.
        this->Controls->Add(this->networkSetupGroupBox);
        this->Controls->Add(this->statusLabel);
        this->Controls->Add(this->controlButton);
        this->Controls->Add(this->ownBoardLabel);
        this->Controls->Add(this->playerOwnBoardPanel);
        this->Controls->Add(this->trackingBoardLabel);
        this->Controls->Add(this->playerTrackingBoardPanel);

        // Wire up Form_Load event handler, typically for actions to perform once the form is loaded (like starting music).
        this->Load += gcnew System::EventHandler(this, &Form1::Form1_Load);

        this->ResumeLayout(false); // Resumes normal layout logic.
        this->PerformLayout(); // Forces the layout of all child controls.
    }

    // Initializes the game grids (both own and tracking boards) by clearing and re-populating them.
    void Form1::InitializeGameGrids() {
        playerOwnBoardPanel->Controls->Clear(); playerTrackingBoardPanel->Controls->Clear(); // Clears any existing buttons from the panels.
        playerOwnBoardPanel->ColumnStyles->Clear(); playerOwnBoardPanel->RowStyles->Clear(); // Clears existing column/row styles for own board.
        playerTrackingBoardPanel->ColumnStyles->Clear(); playerTrackingBoardPanel->RowStyles->Clear(); // Clears styles for tracking board.
        playerOwnBoardPanel->ColumnCount = BOARD_SIZE_CONST; playerOwnBoardPanel->RowCount = BOARD_SIZE_CONST; // Sets column/row count for own board.
        playerTrackingBoardPanel->ColumnCount = BOARD_SIZE_CONST; playerTrackingBoardPanel->RowCount = BOARD_SIZE_CONST; // Sets count for tracking board.
        for (int i = 0; i < BOARD_SIZE_CONST; i++) { // Loop to define column and row styles for the grid.
            playerOwnBoardPanel->ColumnStyles->Add(gcnew ColumnStyle(SizeType::Absolute, Form1::GRID_BUTTON_SIZE)); // Adds absolute sized column.
            playerOwnBoardPanel->RowStyles->Add(gcnew RowStyle(SizeType::Absolute, Form1::GRID_BUTTON_SIZE)); // Adds absolute sized row.
            playerTrackingBoardPanel->ColumnStyles->Add(gcnew ColumnStyle(SizeType::Absolute, Form1::GRID_BUTTON_SIZE)); // Same for tracking board.
            playerTrackingBoardPanel->RowStyles->Add(gcnew RowStyle(SizeType::Absolute, Form1::GRID_BUTTON_SIZE));
        }
        ownBoardButtons = gcnew array<Button^, 2>(BOARD_SIZE_CONST, BOARD_SIZE_CONST); // Creates a 2D array to hold own board buttons.
        trackingBoardButtons = gcnew array<Button^, 2>(BOARD_SIZE_CONST, BOARD_SIZE_CONST); // Creates a 2D array for tracking board buttons.
        CreateGridButtonsForPanel(playerOwnBoardPanel, ownBoardButtons, false); // Populates own board with non-clickable buttons.
        CreateGridButtonsForPanel(playerTrackingBoardPanel, trackingBoardButtons, true); // Populates tracking board with clickable buttons.
    }

    // Creates and configures a grid of buttons for a given TableLayoutPanel.
    // 'panel' is the TableLayoutPanel to populate.
    // 'buttonArray' is a reference to a 2D managed array that will store the created buttons.
    // 'isClickableForAttack' determines if buttons should have click handlers for attacks.
    void Form1::CreateGridButtonsForPanel(TableLayoutPanel^ panel, array<Button^, 2>^% buttonArray, bool isClickableForAttack) {
        panel->SuspendLayout(); // Suspends layout for the panel during modification.
        for (int r = 0; r < BOARD_SIZE_CONST; r++) { // Iterates through rows.
            for (int c = 0; c < BOARD_SIZE_CONST; c++) { // Iterates through columns.
                Button^ button = gcnew Button(); // Creates a new Button control.
                button->Dock = DockStyle::Fill; // Makes the button fill its cell in the TableLayoutPanel.

                // CORRECTED LINE: Ensures Padding struct is explicitly created.
                button->Margin = System::Windows::Forms::Padding(0); // Sets margin to 0 for tight packing.

                button->Tag = Point(r, c); // Stores the button's grid coordinates (row r, column c) in its Tag property.
                button->Name = String::Format(L"{0}{1}_{2}", (isClickableForAttack ? L"track_" : L"own_"), r, c); // Sets a unique name for the button.
                button->FlatStyle = FlatStyle::Flat; // Uses a flat appearance.
                button->FlatAppearance->BorderSize = 1; // Sets border size for the flat button.
                button->FlatAppearance->BorderColor = Color::DarkGray; // Sets border color.
                button->Text = L""; // Initializes button text to empty.
                button->Font = gcnew Drawing::Font(L"Arial", GRID_BUTTON_SIZE / 2.8f, FontStyle::Bold); // Sets font size relative to button size.
                button->TextAlign = ContentAlignment::MiddleCenter; // Centers text on the button.

                if (isClickableForAttack) { // If this grid is for attacking.
                    button->Click += gcnew EventHandler(this, &Form1::OnTrackingBoardClick); // Assigns click event handler.
                    button->BackColor = Color::LightGray; // Sets default background color for attackable cells.
                    button->Enabled = false; // Initially disabled; enabled when it's player's turn.
                }
                else { // If this is an "own board" (display only).
                    button->BackColor = Color::Azure; // Sets default background color for own board cells.
                    button->Enabled = false; // Always disabled for clicks.
                }
                buttonArray[r, c] = button; // Stores the button in the 2D array.
                panel->Controls->Add(button, c, r); // Adds the button to the panel at column 'c', row 'r'.
            }
        }
        panel->ResumeLayout(true); // Resumes layout for the panel and applies changes.
    }

    // Event handler for when the (currently disabled) PvP radio button's checked state changes.
    // If it were enabled, this would reset the game if the mode changed.
    void Form1::OnPvpRadioButtonChanged(System::Object^ sender, System::EventArgs^ e) {
        ResetGameAndUI(); // Resets the game state and UI.
    }

    // Resets the game state and UI to their initial conditions.
    void Form1::ResetGameAndUI() {
        if (this->IsDisposed) return; // If the form is disposed, do nothing.
        // If this method is called from a non-UI thread, invoke it on the UI thread.
        if (this->InvokeRequired) { this->BeginInvoke(gcnew VoidDelegate(this, &Form1::ResetGameAndUI)); return; }
        CleanUpNetworkResources(); // Cleans up any existing network connections or listeners.
        if (gameLogicServer) { delete gameLogicServer; gameLogicServer = nullptr; } // Deletes the native game logic object if it exists.
        isHost = false; isConnected = false; myPlayerId = 0; opponentName = L"Opponent"; // Resets network and player state flags.
        gameActive = false; isMyTurn = false; clientSentReady = false; hostAcknowledgedClientReady = false; // Resets game progression flags.
        for (int r = 0; r < BOARD_SIZE_CONST; ++r) for (int c = 0; c < BOARD_SIZE_CONST; ++c) { // Loop to reset all board buttons.
            if (ownBoardButtons && ownBoardButtons[r, c]) { ownBoardButtons[r, c]->BackColor = Color::Azure; ownBoardButtons[r, c]->Text = L""; } // Reset own board buttons.
            if (trackingBoardButtons && trackingBoardButtons[r, c]) { trackingBoardButtons[r, c]->BackColor = Color::LightGray; trackingBoardButtons[r, c]->Text = L""; } // Reset tracking board buttons.
        }
        Log(L"Game reset. Host or Join, then Ready up."); // Logs a message indicating the game has been reset.
        UpdateUI(); // Updates the UI to reflect the reset state.
    }

    // Updates the entire UI based on the current game state (network connection, active game, whose turn).
    void Form1::UpdateUI() {
        if (this->IsDisposed) return; // If form is disposed, do nothing.
        // If called from non-UI thread, invoke on UI thread.
        if (this->InvokeRequired) { this->BeginInvoke(gcnew VoidDelegate(this, &Form1::UpdateUI)); return; }
        // Log(String::Format(L"UpdateUI: Host={0}, Connected={1}, GameActive={2}, MyTurn={3}", isHost, isConnected, gameActive, isMyTurn)); // Debug log (commented out).
        bool canSetupConnection = !isConnected && !gameActive; // Determines if connection setup controls should be enabled.
        EnableControlOnUI(networkSetupGroupBox, canSetupConnection); // Enables/disables the network setup group box.
        // Player name can be changed if not connected, or if connected but game not active yet.
        EnableControlOnUI(playerNameTextBox, canSetupConnection || (isConnected && !gameActive));
        controlButton->Text = L"Ready"; // Default text for the control button.
        // Enables the "Ready" button if connected, game not active, and based on ready state of host/client.
        EnableControlOnUI(controlButton, isConnected && !gameActive && !(isHost ? hostAcknowledgedClientReady && clientSentReady : clientSentReady));
        playerOwnBoardPanel->Visible = isConnected || gameActive; ownBoardLabel->Visible = playerOwnBoardPanel->Visible; // Shows own board if connected or game active.
        playerTrackingBoardPanel->Visible = gameActive; trackingBoardLabel->Visible = playerTrackingBoardPanel->Visible; // Shows tracking board only if game active.
        msclr::interop::marshal_context context; // For string marshalling (not used in this immediate block).
        if (playerOwnBoardPanel->Visible) { // If the own board is visible.
            String^ uiOpponentName = String::IsNullOrWhiteSpace(opponentName) ? L"Opponent" : opponentName; // Get opponent's name for UI.
            ownBoardLabel->Text = String::Format(L"{0}'s Ships (You)", myNameInternal); // Set own board label text.
            if (playerTrackingBoardPanel->Visible) trackingBoardLabel->Text = String::Format(L"Attacking: {0}", uiOpponentName); // Set tracking board label.
        }
        else { ownBoardLabel->Text = L"Your Ships"; trackingBoardLabel->Text = L"Tracking Board"; } // Default labels if boards hidden.
        if (isHost && gameLogicServer) RedrawBoardsFromServerData(nullptr, nullptr); // If host, redraw boards using server's game logic data.

        bool enableAttackGrid = gameActive && isMyTurn; // Determines if the tracking (attack) grid should be enabled.
        if (trackingBoardButtons) { // If the tracking board buttons array exists.
            for (int r = 0; r < BOARD_SIZE_CONST; ++r) { // Iterate rows.
                for (int c = 0; c < BOARD_SIZE_CONST; ++c) { // Iterate columns.
                    if (trackingBoardButtons[r, c]) { // If button exists.
                        // Enable if it's my turn, game is active, AND the cell hasn't been revealed yet (LightGray or empty text).
                        trackingBoardButtons[r, c]->Enabled = enableAttackGrid && (trackingBoardButtons[r, c]->BackColor == Color::LightGray || String::IsNullOrEmpty(trackingBoardButtons[r, c]->Text));
                    }
                }
            }
        }
    }

    // Redraws the game boards based on data received from the server (or directly from gameLogicServer if host).
    // p1BoardStr_param and p2BoardStr_param are string representations of boards (used by client).
    void Form1::RedrawBoardsFromServerData(String^ p1BoardStr_param, String^ p2BoardStr_param) {
        if (this->IsDisposed) return; // If form disposed, do nothing.
        msclr::interop::marshal_context context; // For string marshalling.
        if (isHost && gameLogicServer && gameLogicServer->GetPlayer1()) { // If this instance is the host and has game logic.
            Player* p1_logic = gameLogicServer->GetPlayer1ForUpdate(); // Get a pointer to player 1's data from server logic.
            for (int r = 0; r < BOARD_SIZE_CONST; ++r) for (int c = 0; c < BOARD_SIZE_CONST; ++c) { // Iterate board cells.
                char p1Cell = p1_logic->getOwnBoardCell(r, c); // Get state of P1's own cell.
                // Update own board button appearance.
                if (ownBoardButtons && ownBoardButtons[r, c]) { ownBoardButtons[r, c]->Text = L""; ownBoardButtons[r, c]->BackColor = (p1Cell == SHIP_CHAR) ? Color::DarkGray : (p1Cell == HIT_CHAR) ? Color::OrangeRed : (p1Cell == MISS_CHAR) ? Color::LightSkyBlue : Color::Azure; }
                char p1TrackCell = p1_logic->getTrackingBoardCell(r, c); // Get state of P1's tracking cell.
                // Update tracking board button appearance.
                if (trackingBoardButtons && trackingBoardButtons[r, c]) {
                    trackingBoardButtons[r, c]->Text = (p1TrackCell == HIT_CHAR) ? L"H" : (p1TrackCell == MISS_CHAR) ? L"M" : L""; // Set H/M text.
                    trackingBoardButtons[r, c]->BackColor = (p1TrackCell == HIT_CHAR) ? Color::Red : (p1TrackCell == MISS_CHAR) ? Color::Blue : Color::LightGray; // Set color.
                }
            }
        }
        else if (!isHost) { // If this instance is the client.
            // Check if received board strings are valid.
            if (String::IsNullOrEmpty(p1BoardStr_param) || String::IsNullOrEmpty(p2BoardStr_param)) { Log(L"CLIENT: Null/empty board strings for RedrawBoardsFromServerData."); return; }
            std::string host_board_std = context.marshal_as<std::string>(p1BoardStr_param); // Marshal host's board string (P1's board).
            std::string my_board_std = context.marshal_as<std::string>(p2BoardStr_param); // Marshal my board string (P2's board).
            // Validate board string lengths.
            if (host_board_std.length() != BOARD_SIZE_CONST * BOARD_SIZE_CONST || my_board_std.length() != BOARD_SIZE_CONST * BOARD_SIZE_CONST) { Log(L"CLIENT: Invalid board string length for Redraw."); return; }
            for (int r = 0; r < BOARD_SIZE_CONST; ++r) for (int c = 0; c < BOARD_SIZE_CONST; ++c) { // Iterate board cells.
                char cellStateMyOwn = my_board_std[r * BOARD_SIZE_CONST + c]; // Get state of my own cell from string.
                // Update my own board button appearance.
                if (ownBoardButtons && ownBoardButtons[r, c]) { ownBoardButtons[r, c]->Text = L""; ownBoardButtons[r, c]->BackColor = (cellStateMyOwn == SHIP_CHAR) ? Color::DarkGray : (cellStateMyOwn == HIT_CHAR) ? Color::OrangeRed : (cellStateMyOwn == MISS_CHAR) ? Color::LightSkyBlue : Color::Azure; }
                char cellStateOnHost = host_board_std[r * BOARD_SIZE_CONST + c]; // Get state of cell on host's board (my tracking view).
                // Update my tracking board button appearance.
                if (trackingBoardButtons && trackingBoardButtons[r, c]) {
                    if (cellStateOnHost == HIT_CHAR) { trackingBoardButtons[r, c]->BackColor = Color::Red; trackingBoardButtons[r, c]->Text = "H"; }
                    else if (cellStateOnHost == MISS_CHAR) { trackingBoardButtons[r, c]->BackColor = Color::Blue; trackingBoardButtons[r, c]->Text = "M"; }
                    else { trackingBoardButtons[r, c]->BackColor = Color::LightGray; trackingBoardButtons[r, c]->Text = ""; }
                }
            }
        }
    }

    // Logs a message to the statusLabel, ensuring it's done on the UI thread.
    void Form1::Log(String^ message) {
        if (this->IsDisposed) return; // If form disposed, do nothing.
        // If called from non-UI thread, invoke LogOnUIThread on UI thread.
        if (this->InvokeRequired) { this->BeginInvoke(gcnew StringArgDelegate(this, &Form1::LogOnUIThread), message); }
        else { LogOnUIThread(message); } // Otherwise, call directly.
    }
    // Helper method that actually updates the statusLabel on the UI thread.
    void Form1::LogOnUIThread(String^ text) {
        if (this->IsDisposed || statusLabel == nullptr) return; // If form/label disposed, do nothing.
        // Prepends new log message with timestamp to existing statusLabel text.
        statusLabel->Text = String::Concat(DateTime::Now.ToLongTimeString(), L": ", text, Environment::NewLine, statusLabel->Text);
        // Splits statusLabel text into lines.
        array<String^>^ lines = statusLabel->Text->Split(gcnew array<Char>{'\n'}, StringSplitOptions::RemoveEmptyEntries);
        if (lines->Length > 20) { // If more than 20 log lines, trim to keep only the newest 20.
            StringBuilder^ sb = gcnew StringBuilder();
            for (int i = 0; i < 20; i++) { sb->AppendLine(lines[i]); } // Rebuild with newest lines.
            statusLabel->Text = sb->ToString(); // Update label.
        }
    }
    // Helper method to ensure UpdateUI is called on the UI thread.
    void Form1::UpdateUIOnUIThread() {
        if (this->IsDisposed) return; // If form disposed, do nothing.
        if (this->InvokeRequired) { this->BeginInvoke(gcnew VoidDelegate(this, &Form1::UpdateUI)); } // Invoke if needed.
        else { UpdateUI(); } // Call directly if on UI thread.
    }
    // Helper method to enable/disable a control on the UI thread.
    void Form1::EnableControlOnUI(Control^ ctl, bool enable) {
        if (ctl == nullptr || ctl->IsDisposed) return; // If control invalid, do nothing.
        if (ctl->InvokeRequired) { ctl->BeginInvoke(gcnew ControlBoolDelegate(this, &Form1::EnableControlOnUI), ctl, enable); } // Invoke if needed.
        else { ctl->Enabled = enable; } // Set Enabled property directly.
    }

    // Starts the process of hosting a game.
    void Form1::StartHosting() {
        if (tcpListener != nullptr) { Log(L"Already hosting."); return; } // If already listening, do nothing.
        try {
            int port = Convert::ToInt32(portTextBox->Text); // Get port from TextBox.
            tcpListener = gcnew TcpListener(IPAddress::Any, port); // Create listener on any local IP, specified port.
            tcpListener->Start(); // Start listening for incoming connections.
            Log(String::Format(L"Hosting on port {0}...", port)); // Log hosting status.
            isHost = true; myPlayerId = 1; isConnected = false; // Set host state. Player 1 is host.
            myNameInternal = playerNameTextBox->Text; if (String::IsNullOrWhiteSpace(myNameInternal)) myNameInternal = L"Host"; // Set host's name.
            listenThread = gcnew Thread(gcnew ThreadStart(this, &Form1::ListenForConnections)); // Create thread for listening.
            listenThread->IsBackground = true; // Make it a background thread (won't keep app alive).
            listenThread->Start(); // Start the listening thread.
        }
        catch (Exception^ ex) { Log(String::Format(L"Host Error: {0}", ex->Message)); CleanUpNetworkResources(); } // Log error and cleanup.
        UpdateUI(); // Update UI to reflect hosting state.
    }
    // Method executed on a separate thread to listen for incoming client connections.
    void Form1::ListenForConnections() {
        try {
            if (tcpListener == nullptr && !IsDisposed) { Log(L"Listener null in ListenForConnections"); return; } // Check listener.
            opponentClient = tcpListener->AcceptTcpClient(); // Blocks until a client connects.
            if (tcpListener != nullptr) tcpListener->Stop(); tcpListener = nullptr; // Stop listening once a client connects (1v1 game).
            HandleClientConnection(opponentClient); // Handle the connected client.
        }
        catch (Exception^ ex) { if (!IsDisposed && isHost) Log(String::Format(L"Listen Error: {0}", ex->Message)); HandleDisconnection(L"Listen Error"); } // Log error and handle disconnection.
    }
    // Handles a new client connection once accepted by the listener.
    void Form1::HandleClientConnection(TcpClient^ client) {
        if (this->IsDisposed || client == nullptr) return; // If form disposed or client null, do nothing.
        opponentStream = client->GetStream(); // Gets the NetworkStream for communication with the client.
        isConnected = true; // Sets connected flag.
        Log(L"Client connected. Waiting for client name (CONNECT_REQUEST)..."); // Log status.
        receiveThread = gcnew Thread(gcnew ParameterizedThreadStart(this, &Form1::ReceiveMessages)); // Create thread for receiving messages from client.
        receiveThread->IsBackground = true; // Set as background thread.
        receiveThread->Start(opponentStream); // Start receive thread, passing the stream.
        UpdateUI(); // Update UI.
    }
    // Starts the process of joining an existing game hosted by another player.
    void Form1::StartJoining() {
        if (serverConnection != nullptr && serverConnection->Connected) { Log(L"Already connected."); return; } // If already connected, do nothing.
        try {
            String^ ip = serverIpTextBox->Text; int port = Convert::ToInt32(portTextBox->Text); // Get IP and port from TextBoxes.
            myNameInternal = playerNameTextBox->Text; if (String::IsNullOrWhiteSpace(myNameInternal)) myNameInternal = L"Client"; // Set client's name.
            Log(String::Format(L"Joining {0}:{1}...", ip, port)); // Log joining attempt.
            serverConnection = gcnew TcpClient(); // Create a new TcpClient for connecting to server.
            isHost = false; myPlayerId = 2; // Set client state. Player 2 is client.
            serverConnection->Connect(ip, port); // Attempt to connect to the server.
            if (serverConnection->Connected) { // If connection successful.
                serverStream = serverConnection->GetStream(); isConnected = true; Log(L"Connected! Sending my name."); // Get stream, set connected.
                SendNetMessage(serverStream, String::Format(L"CONNECT_REQUEST {0}", myNameInternal)); // Send initial connect request with name.
                receiveThread = gcnew Thread(gcnew ParameterizedThreadStart(this, &Form1::ReceiveMessages)); // Create thread for receiving messages.
                receiveThread->IsBackground = true; // Set as background.
                receiveThread->Start(serverStream); // Start receive thread.
            }
            else { HandleDisconnection(L"Failed to connect flag"); } // If connect failed, handle disconnection.
        }
        catch (Exception^ ex) { Log(String::Format(L"Join Error: {0}", ex->Message)); CleanUpNetworkResources(); } // Log error and cleanup.
        UpdateUI(); // Update UI.
    }
    // Method executed on a separate thread to continuously receive messages from the opponent/server.
    // 'streamObj' is the NetworkStream to read from.
    void Form1::ReceiveMessages(Object^ streamObj) {
        NetworkStream^ stream = safe_cast<NetworkStream^>(streamObj); // Safely cast object to NetworkStream.
        if (stream == nullptr) { if (!this->IsDisposed) Log(L"ReceiveMessages: Stream object is null."); HandleDisconnection(L"Null stream in Receive"); return; } // Check if stream is null.
        StreamReader^ reader = gcnew StreamReader(stream, Encoding::UTF8); // Create StreamReader for text-based messages.
        String^ msg; // Variable to hold the received message.
        try {
            while ((msg = reader->ReadLine()) != nullptr) { // Loop while messages are being read (ReadLine blocks).
                if (IsDisposed) break; // If form is disposed, exit loop.
                msclr::lock l(queueLock); UIMessageQueue->Enqueue(msg); // Lock the queue and add the message for UI thread processing.
            }
        }
        catch (IOException^) { // Catch IO exceptions (often indicate connection lost).
            if (!IsDisposed) Log(L"Connection lost (IOExc).");
        }
        catch (ObjectDisposedException^) { // Catch if stream was disposed elsewhere.
            if (!IsDisposed) Log(L"Stream closed (ObjDispExc).");
        }
        catch (Exception^ ex) { // Catch any other exceptions.
            if (!IsDisposed) Log(String::Format(L"Receive Error: {0}", ex->Message));
        }
        finally { if (!IsDisposed) HandleDisconnection(L"Receive loop ended"); } // Ensure disconnection is handled when loop ends.
    }
    // Sends a network message (string) over the given NetworkStream.
    void Form1::SendNetMessage(NetworkStream^ stream, String^ message) {
        // Check if can send (form not disposed, stream valid and writable).
        if (this->IsDisposed || stream == nullptr || !stream->CanWrite) { if (!IsDisposed) Log(L"SendNetMessage: Cannot send, stream invalid."); return; }
        try {
            array<Byte>^ data = Encoding::UTF8->GetBytes(String::Concat(message, L"\n")); // Convert message string to byte array (UTF-8) and add newline.
            stream->Write(data, 0, data->Length); // Write data to the stream.
            stream->Flush(); // Flush the stream to ensure data is sent immediately.
            // Log(String::Format(L"NetSENT: {0}", message->Length > 60 ? message->Substring(0,60)+L"..." : message)); // Debug log for sent messages (commented out for reduced logging).
        }
        catch (Exception^ ex) { Log(String::Format(L"Send Error for '{0}': {1}", message->Length > 30 ? message->Substring(0, 30) + L"..." : message, ex->Message)); HandleDisconnection(String::Format(L"Send error: {0}", ex->Message)); } // Log send error and handle disconnection.
    }
    // Cleans up all network-related resources (threads, streams, clients, listeners).
    void Form1::CleanUpNetworkResources() {
        isConnected = false; gameActive = false; // Reset connection/game flags.
        // Safely stop and join/abort listenThread.
        if (listenThread != nullptr) { if (tcpListener) tcpListener->Stop(); try { if (listenThread->IsAlive) { listenThread->Join(100); if (listenThread->IsAlive) listenThread->Abort(); } } catch (Exception^) {} listenThread = nullptr; }
        // Safely stop and join/abort receiveThread.
        if (receiveThread != nullptr) { try { if (receiveThread->IsAlive) { receiveThread->Join(100); if (receiveThread->IsAlive) receiveThread->Abort(); } } catch (Exception^) {} receiveThread = nullptr; }
        // Close streams and clients, catching exceptions.
        if (opponentStream) { try { opponentStream->Close(); } catch (Exception^) {} opponentStream = nullptr; } if (opponentClient) { try { opponentClient->Close(); } catch (Exception^) {} opponentClient = nullptr; }
        if (serverStream) { try { serverStream->Close(); } catch (Exception^) {} serverStream = nullptr; } if (serverConnection) { try { serverConnection->Close(); } catch (Exception^) {} serverConnection = nullptr; }
        if (tcpListener) { try { tcpListener->Stop(); } catch (Exception^) {} tcpListener = nullptr; } // Stop listener if still active.
        // if(!IsDisposed) Log(L"Network resources cleaned."); // Log cleanup (commented out).
    }

    // Handles a disconnection event, ensuring UI reset is done on the UI thread.
    // 'reason' is a string indicating why disconnection occurred.
    void Form1::HandleDisconnection(String^ reason) {
        if (this->IsDisposed) return; // If form disposed, do nothing.
        Log(String::Format(L"Disconnection event ({0}). Scheduling UI reset.", reason)); // Log the disconnection reason.
        if (InvokeRequired) { // If called from non-UI thread.
            this->BeginInvoke(gcnew VoidDelegate(this, &Form1::HandleDisconnection_UIThreadAction)); // Invoke action on UI thread.
        }
        else { // If already on UI thread.
            HandleDisconnection_UIThreadAction(); // Call action directly.
        }
    }
    // Action to perform on the UI thread when a disconnection occurs.
    void Form1::HandleDisconnection_UIThreadAction() {
        if (this->IsDisposed) return; // If form disposed, do nothing.
        // Log(L"Processing disconnection on UI Thread: Resetting game and UI."); // Debug log (commented out).
        ResetGameAndUI(); // Calls the main reset function.
    }

    // Event handler for the "Host Game" button click.
    void Form1::OnHostGameClick(Object^ sender, EventArgs^ e) { StartHosting(); } // Calls the StartHosting method.
    // Event handler for the "Join Game" button click.
    void Form1::OnJoinGameClick(Object^ sender, EventArgs^ e) { StartJoining(); } // Calls the StartJoining method.

    // Event handler for the main control button (e.g., "Ready").
    void Form1::OnControlButtonClick(Object^ sender, EventArgs^ e) {
        if (!isConnected) { Log(L"Not connected. Host or Join first."); return; } // If not connected, do nothing.
        msclr::interop::marshal_context context; // For string marshalling.
        myNameInternal = playerNameTextBox->Text; // Get player's name from TextBox.
        // Set default name if empty.
        if (String::IsNullOrWhiteSpace(myNameInternal)) myNameInternal = isHost ? L"HostPlayer" : L"ClientPlayer";

        if (isHost) { // If this instance is the host.
            hostAcknowledgedClientReady = true; // Host marks itself as ready (or acknowledges its own ready state).
            Log(String::Format(L"Host ({0}) is Ready.", myNameInternal)); // Log host ready.
            if (!gameLogicServer) { // If game logic server doesn't exist yet.
                gameLogicServer = new BattleshipGameLogic(); // Create new game logic.
                // Start a new game with host's name and a temporary/default opponent name.
                gameLogicServer->StartNewGame(context.marshal_as<std::string>(myNameInternal), context.marshal_as<std::string>(String::IsNullOrWhiteSpace(opponentName) || opponentName == "Opponent" ? "Player2_Tmp" : opponentName));
            }
            else { if (gameLogicServer->GetPlayer1ForUpdate()) gameLogicServer->GetPlayer1ForUpdate()->setName(context.marshal_as<std::string>(myNameInternal)); } // Update P1 name if logic exists.

            if (clientSentReady) { // If the client has also indicated they are ready.
                gameActive = true; isMyTurn = true; // Game becomes active, host starts (P1).
                if (!gameLogicServer) gameLogicServer = new BattleshipGameLogic(); // Ensure game logic exists.
                // Set player names in the game logic.
                gameLogicServer->GetPlayer1ForUpdate()->setName(context.marshal_as<std::string>(myNameInternal));
                if (gameLogicServer->GetPlayer2ForUpdate()) gameLogicServer->GetPlayer2ForUpdate()->setName(context.marshal_as<std::string>(opponentName));
                else { gameLogicServer->StartNewGame(context.marshal_as<std::string>(myNameInternal), context.marshal_as<std::string>(opponentName)); } // Or start new if P2 was temp.

                Log(L"HOST: Both players ready. Sending initial GAME_UPDATE."); // Log status.
                // Get board states and last action from game logic.
                String^ p1Board = context.marshal_as<String^>(gameLogicServer->GetPlayer1()->getOwnBoardAsString());
                String^ p2Board = context.marshal_as<String^>(gameLogicServer->GetPlayer2()->getOwnBoardAsString());
                String^ lastAction = context.marshal_as<String^>(gameLogicServer->GetLastActionMessage());
                // Construct GAME_UPDATE message to send to client.
                String^ gameUpdateMsg = String::Format(L"GAME_UPDATE {0} {1} {2} {3} {4} {5}",
                    1, p1Board, p2Board, lastAction->Replace(" ", "_SPACE_"), Boolean::FalseString, L"N/A"); // Turn ID 1 (P1), boards, action, not game over, no winner yet.
                SendNetMessage(opponentStream, gameUpdateMsg); // Send message to client.
                ProcessUIMessage(gameUpdateMsg); // Process the same message locally for host's UI.
            }
            else { Log(L"Host ready, waiting for Client to send READY signal."); } // If client not ready yet.
        }
        else { // If this instance is the client.
            clientSentReady = true; // Client marks itself as ready.
            SendNetMessage(serverStream, L"READY"); // Sends "READY" message to the host.
            Log(L"Client: Sent READY to Host. Waiting for GAME_UPDATE to start game."); // Log status.
        }
        UpdateUI(); // Update UI based on new state.
    }

    // Event handler for clicking a cell on the tracking board (making an attack).
    void Form1::OnTrackingBoardClick(Object^ sender, EventArgs^ e) {
        Button^ clickedButton = dynamic_cast<Button^>(sender); if (!clickedButton || !clickedButton->Enabled) return; // If button invalid or disabled, do nothing.
        Point cell = safe_cast<Point>(clickedButton->Tag); // Get cell coordinates from button's Tag.
        clickedButton->Enabled = false; // Disable clicked button immediately to prevent double-clicks.

        if (gameActive && isMyTurn) { // If game is active and it's this player's turn.
            msclr::interop::marshal_context context; // For string marshalling.
            if (isHost) { // If this instance is the host.
                if (!gameLogicServer) { Log(L"HOST: No game logic on attack!"); return; } // Should not happen.
                gameLogicServer->MakeAttack(cell.X, cell.Y); // Host makes attack in its local game logic.

                // Get updated game state from server logic.
                String^ p1Board = context.marshal_as<String^>(gameLogicServer->GetPlayer1()->getOwnBoardAsString());
                String^ p2Board = context.marshal_as<String^>(gameLogicServer->GetPlayer2()->getOwnBoardAsString());
                String^ lastAction = context.marshal_as<String^>(gameLogicServer->GetLastActionMessage());
                bool gameOver = gameLogicServer->IsGameOver();
                String^ winner = gameOver ? context.marshal_as<String^>(gameLogicServer->GetWinnerString()) : L"";
                int nextTurnId = gameOver ? 0 : ((gameLogicServer->GetCurrentTurnState() == GameTurn::PLAYER1) ? 1 : 2); // Determine next turn ID.
                if (gameOver && gameLogicServer->GetCurrentTurnState() == GameTurn::GAME_OVER_P1_WINS) nextTurnId = 1; // If P1 won, "turn" is P1.
                else if (gameOver && gameLogicServer->GetCurrentTurnState() == GameTurn::GAME_OVER_P2_WINS) nextTurnId = 2; // If P2 won, "turn" is P2.

                // Construct GAME_UPDATE message with new state.
                String^ gameUpdateMsg = String::Format(L"GAME_UPDATE {0} {1} {2} {3} {4} {5}",
                    nextTurnId, p1Board, p2Board, lastAction->Replace(" ", "_SPACE_"), // Replace spaces for network transmission.
                    gameOver.ToString(), winner->Replace(" ", "_SPACE_"));

                SendNetMessage(opponentStream, gameUpdateMsg); // Send update to client.
                ProcessUIMessage(gameUpdateMsg); // Process update locally for host's UI.
            }
            else { // If this instance is the client.
                // Log(String::Format(L"CLIENT: Sending ATTACK {0} {1}", cell.X, cell.Y)); // Debug log (commented out).
                SendNetMessage(serverStream, String::Format(L"ATTACK {0} {1}", cell.X, cell.Y)); // Send ATTACK message to host.
                isMyTurn = false; // Client assumes turn is over after sending attack.
            }
        }
        else { Log(L"Cannot attack: Not your turn or game not active."); if (clickedButton) clickedButton->Enabled = true; } // If not turn or game inactive, re-enable button.
        UpdateUI(); // Update UI.
    }

    // Processes a received network message string to update game state and UI.
    void Form1::ProcessUIMessage(String^ message) {
        if (this->IsDisposed) return; // If form disposed, do nothing.
        array<String^>^ parts = message->Split(L' '); // Split message into parts by space.
        String^ command = parts[0]; // First part is the command.
        msclr::interop::marshal_context context; // For string marshalling.

        // Log(String::Format(L"UI_Process: {0}", message->Length > 80 ? message->Substring(0,80)+L"..." : message)); // Debug log (commented out).

        if (command == L"CONNECT_REQUEST" && isHost && parts->Length > 1) { // Host receives connect request from client.
            opponentName = parts[1]; for (int i = 2; i < parts->Length; ++i) opponentName = String::Concat(opponentName, " ", parts[i]); // Reconstruct opponent name if it has spaces.
            if (String::IsNullOrWhiteSpace(opponentName)) opponentName = L"ClientPlayer"; // Default opponent name if empty.
            Log(String::Format(L"Host: Received CONNECT_REQUEST from '{0}'. Sending WELCOME.", opponentName)); // Log event.
            if (!gameLogicServer) gameLogicServer = new BattleshipGameLogic(); // Ensure game logic exists.
            // Start new game in server logic with host and client names.
            gameLogicServer->StartNewGame(context.marshal_as<std::string>(String::IsNullOrWhiteSpace(myNameInternal) ? "Host" : myNameInternal), context.marshal_as<std::string>(opponentName));
            SendNetMessage(opponentStream, String::Format(L"WELCOME {0} {1} {2}", myNameInternal, opponentName, 2)); // Send WELCOME to client (my name, opponent name, client's player ID is 2).
        }
        else if (command == L"WELCOME" && !isHost && parts->Length > 3) { // Client receives welcome message from host.
            opponentName = parts[1]; // Host's name.
            myPlayerId = Convert::ToInt32(parts[3]); // My player ID (should be 2).
            Log(String::Format(L"Client: Welcome from Host '{0}'. I am Player {1}.", opponentName, myPlayerId)); // Log event.
        }
        else if (command == L"READY" && isHost) { // Host receives "READY" from client.
            clientSentReady = true; Log(L"Host: Client sent READY."); // Mark client as ready.
            if (hostAcknowledgedClientReady) { // If host is also ready.
                gameActive = true; isMyTurn = true; // Game starts, host's turn.
                if (!gameLogicServer) gameLogicServer = new BattleshipGameLogic(); // Ensure game logic.
                String^ effectiveOpponentName = String::IsNullOrWhiteSpace(opponentName) || opponentName == "Opponent" ? "Player2_Tmp" : opponentName; // Get effective opponent name.
                // Start new game or update names in existing logic.
                gameLogicServer->StartNewGame(context.marshal_as<std::string>(myNameInternal), context.marshal_as<std::string>(effectiveOpponentName));
                Log(L"HOST: Both players ready. Sending initial GAME_UPDATE."); // Log status.
                // Get initial board states and action.
                String^ p1Board = context.marshal_as<String^>(gameLogicServer->GetPlayer1()->getOwnBoardAsString());
                String^ p2Board = context.marshal_as<String^>(gameLogicServer->GetPlayer2()->getOwnBoardAsString());
                String^ lastAction = context.marshal_as<String^>(gameLogicServer->GetLastActionMessage());
                // Construct and send initial GAME_UPDATE.
                String^ gameUpdateMsg = String::Format(L"GAME_UPDATE {0} {1} {2} {3} {4} {5}",
                    1, p1Board, p2Board, lastAction->Replace(" ", "_SPACE_"), Boolean::FalseString, L"N/A");
                SendNetMessage(opponentStream, gameUpdateMsg); ProcessUIMessage(gameUpdateMsg); // Send and process locally.
            }
        }
        else if (command == L"ATTACK" && isHost && parts->Length == 3) { // Host receives ATTACK from client.
            if (!gameLogicServer || !gameActive) { Log(L"HOST: Received ATTACK but game not active/ready."); return; } // If game not ready, ignore.
            int r = Convert::ToInt32(parts[1]); int c = Convert::ToInt32(parts[2]); // Parse attack coordinates.
            // Log(String::Format(L"HOST: Processing client ATTACK {0},{1}", r,c)); // Debug log (commented out).
            gameLogicServer->MakeAttack(r, c); // Host processes client's attack in its game logic.
            // Get updated game state.
            String^ p1Board = context.marshal_as<String^>(gameLogicServer->GetPlayer1()->getOwnBoardAsString());
            String^ p2Board = context.marshal_as<String^>(gameLogicServer->GetPlayer2()->getOwnBoardAsString());
            String^ lastAction = context.marshal_as<String^>(gameLogicServer->GetLastActionMessage());
            bool gameOver = gameLogicServer->IsGameOver();
            String^ winner = gameOver ? context.marshal_as<String^>(gameLogicServer->GetWinnerString()) : L"";
            int nextTurnId = (gameLogicServer->GetCurrentTurnState() == GameTurn::PLAYER1) ? 1 : 2; // Determine next turn.
            if (gameOver) nextTurnId = (gameLogicServer->GetCurrentTurnState() == GameTurn::GAME_OVER_P1_WINS) ? 1 : (gameLogicServer->GetCurrentTurnState() == GameTurn::GAME_OVER_P2_WINS ? 2 : 0); // Set turn based on winner.
            // Construct and send GAME_UPDATE.
            String^ gameUpdateMsg = String::Format(L"GAME_UPDATE {0} {1} {2} {3} {4} {5}",
                nextTurnId, p1Board, p2Board, lastAction->Replace(" ", "_SPACE_"), gameOver.ToString(), winner->Replace(" ", "_SPACE_"));
            SendNetMessage(opponentStream, gameUpdateMsg); ProcessUIMessage(gameUpdateMsg); // Send and process locally.
        }
        else if (command == L"GAME_UPDATE" && parts->Length >= 6) { // Both host and client receive GAME_UPDATE.
            try {
                // Parse GAME_UPDATE message parts.
                int currentTurnId_from_server = Convert::ToInt32(parts[1]);
                String^ p1Board_str = parts[2]; String^ p2Board_str = parts[3];
                String^ lastActionMessage_Received = parts[4]->Replace(L"_SPACE_", L" "); // Restore spaces.
                bool gameOver_Received = Boolean::Parse(parts[5]);
                String^ winnerMessage_Received = (parts->Length > 6 && parts[6] != L"N/A") ? parts[6]->Replace(L"_SPACE_", L" ") : L""; // Get winner message.
                if (parts->Length > 7) { for (int i = 7; i < parts->Length; ++i) winnerMessage_Received = String::Concat(winnerMessage_Received, L" ", parts[i]->Replace(L"_SPACE_", L" ")); } // Reconstruct multi-part winner message.

                // Log(String::Format(L"Side ({0}): Recvd GAME_UPDATE. TurnForP{1}. GameOver={2}. LastAction='{3}' Winner='{4}'", (isHost?L"Host":L"Client"), currentTurnId_from_server, gameOver_Received, lastActionMessage_Received, winnerMessage_Received)); // Debug log (commented out).
                gameActive = !gameOver_Received; // Update game active state.
                isMyTurn = (currentTurnId_from_server == myPlayerId) && gameActive; // Update whose turn it is.
                // Log(String::Format(L"Side ({0}): After GAME_UPDATE, isMyTurn = {1}", (isHost?L"Host":L"Client"), isMyTurn)); // Debug log (commented out).
                RedrawBoardsFromServerData(p1Board_str, p2Board_str); // Redraw boards based on received data.
                if (statusLabel != nullptr) statusLabel->Text = lastActionMessage_Received; // Update status label with last action.
                if (gameOver_Received) { // If game is over.
                    Log(String::Format(L"Side ({0}): Game Over! {1}", (isHost ? L"Host" : L"Client"), winnerMessage_Received)); // Log game over.
                    MessageBox::Show(String::Format(L"Game Over! {0}", winnerMessage_Received), L"Game Over", MessageBoxButtons::OK); // Show message box.
                }
            }
            catch (Exception^ ex) { Log(String::Format(L"Error processing GAME_UPDATE: {0}. Msg: {1}", ex->Message, message)); } // Log error during processing.
        }
        else if (command == L"DISCONNECT" || command == L"SERVER_SHUTDOWN") { // If disconnect or server shutdown message received.
            Log(String::Format(L"Received {0}. Disconnecting.", command)); // Log event.
            HandleDisconnection(command); // Handle disconnection.
        }
        UpdateUI(); // Update UI after processing message.
    }

    // Event handler for the message processing timer's Tick event.
    void Form1::OnMessageProcessTimerTick(Object^ sender, EventArgs^ e) {
        if (IsDisposed) return; // If form disposed, do nothing.
        String^ msg = nullptr; // Variable to hold dequeued message.
        msclr::lock l(queueLock); if (UIMessageQueue->Count > 0) msg = UIMessageQueue->Dequeue(); l.release(); // Lock queue, dequeue message if available, release lock.
        if (msg != nullptr) ProcessUIMessage(msg); // If a message was dequeued, process it.
    }

    // Event handler for the Form's Load event (fires when the form is first loaded).
    void Form1::Form1_Load(Object^ sender, EventArgs^ e) {
        try { // Try block for music playback.
            // Check if music player is ready and sound location is set.
            if (backgroundMusicPlayer != nullptr && !String::IsNullOrEmpty(backgroundMusicPlayer->SoundLocation) && backgroundMusicPlayer->IsLoadCompleted) {
                backgroundMusicPlayer->PlayLooping(); Log(L"Background music started."); // Play music if loaded.
            }
            // If not loaded but location set, check file existence and try to play.
            else if (backgroundMusicPlayer != nullptr && !String::IsNullOrEmpty(backgroundMusicPlayer->SoundLocation)) {
                String^ audioFilePath = Path::Combine(Application::StartupPath, "background_music.wav");
                if (!File::Exists(audioFilePath)) { Log(L"Music file 'background_music.wav' not found (Form_Load)."); }
                else { Log(L"Music attempting to play (Form_Load)."); backgroundMusicPlayer->PlayLooping(); }
            }
            else { Log(L"Music player not ready or sound location not set (Form_Load)."); } // Log if music not ready.
        }
        catch (Exception^ ex) { Log(String::Format(L"Error playing background music in Form_Load: {0}", ex->Message)); } // Log music playback error.
    }

    // Event handler for the Form's Closing event (fires when the form is about to close).
    void Form1::OnFormClosing(Object^ sender, FormClosingEventArgs^ e) {
        Log(L"Form closing..."); // Log form closing.
        if (backgroundMusicPlayer != nullptr) { backgroundMusicPlayer->Stop(); } // Stop background music.
        NetworkStream^ streamToUse = isHost ? opponentStream : serverStream; // Determine which stream is active.
        // If connected and stream is writable, send a DISCONNECT message.
        if (isConnected && streamToUse != nullptr && streamToUse->CanWrite) { SendNetMessage(streamToUse, L"DISCONNECT"); }
        CleanUpNetworkResources(); // Clean up all network resources.
    }

} // End of namespace BattleshipGame